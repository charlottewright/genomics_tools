#!/usr/bin/env python3
#%%
import sys
import argparse
from enum import unique
import pandas as pd
#%%

# Parse input file and calculate chunks
def calculate_gc_per_chunk(gc_file, chunks):
    with open(gc_file) as table:
        for line in table:
            cols = line.rstrip("\n").split('\t')
            chr, start, stop, gc = cols[0], int(cols[1]), int(cols[2]), float(cols[3])
            # get right chr
            chr_chunks = chunks[(chunks['chr'] == chr)]
            first_chunk = chr_chunks.head(1) # to get size of chunk
            chunk_size = first_chunk['stop'] - first_chunk['start']
            first_chunk = int(start / chunk_size) # in 1.2 chunks i.e. between 1 and 2. Int gives 1.
            last_chunk = int(stop / chunk_size) + 1 # index of the last possible chunk that could overlap with window
            for i in range(first_chunk,(last_chunk+1),1):
                end_chunk = int(chunk_size)*i # to get actual end position of chunk rather than its index
                start_chunk = end_chunk - int(chunk_size) # get actual start position of chunk
                # find number of bases overlapping between the current chunk and the window
                overlapping_bases = len(set(range(start,stop)).intersection(range(start_chunk,end_chunk)))
                #print(i, start_chunk, end_chunk, overlapping_bases)
                row_number = chunks.index[(chunks['chr'] == chr) & (chunks['start'] == start_chunk) & (chunks['stop'] == end_chunk)].to_list()
                current_gc_total = chunks.loc[row_number, 'gc_total'] 
                current_gc_length = chunks.loc[row_number, 'gc_length'] 
                new_gc_total = current_gc_total + (gc*overlapping_bases)
                new_gc_length = current_gc_length + overlapping_bases
                chunks.loc[row_number,['gc_total']] = new_gc_total
                chunks.loc[row_number,['gc_length']] = new_gc_length
    return chunks
#%%
# Warning this script is slow!
if __name__ == "__main__":
    SCRIPT = "calculate_gc_per_window.py"
    # Argument set up
    parser = argparse.ArgumentParser()
    parser.add_argument("-b", "--bed_file", type=str, help = "Bed file for the chunks", required=True)
    parser.add_argument("-gc", "--gc_windows", type=str, help = "GC windows generated by fasta_windows", required=True)
    parser.add_argument("-o", "--output", type=str, help = "Prefix for output file", required=True)
    args = parser.parse_args()
    bed_file = args.bed_file
    gc_file = args.gc_windows
    prefix = args.output

    # main
    colnames = ['chr', 'start', 'stop']
    chunks = pd.read_csv(bed_file, sep='\t', names=colnames, dtype={'chr':"string", 'start':"int64", 'stop':"int64"})
    chunks['gc_total'], chunks['gc_length'] = 0, 0 #Â initalise empty cols
    chunks = calculate_gc_per_chunk(gc_file, chunks)
    chunks['gc_per'] = chunks['gc_total'] / chunks['gc_length']
    chunks = chunks[['chr', 'start', 'stop', 'gc_per']]
    chunks['gc_per'] = chunks['gc_per'].round(3)
    chunks.to_csv(str(prefix + '.gc.tsv'), sep='\t', index=False)

# manual run
#bed_file = 'Orgyia_antiqua.chunked_chr_100.bed'
